package semaphore

import (
	"fmt"
	"math/big"

	"github.com/NguyenHiu/semaphore-implementation-in-go/circuits"
	"github.com/NguyenHiu/semaphore-implementation-in-go/leanIMT"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/groth16"
	groth16_bn254 "github.com/consensys/gnark/backend/groth16/bn254"
	"github.com/consensys/gnark/constraint"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
)

// Setup performs the setup phase of the Semaphore circuit
func SetupCircuit() (
	constraint.ConstraintSystem,
	groth16.ProvingKey,
	groth16.VerifyingKey,
	error,
) {
	// Compile the circuit
	ccs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuits.Semaphore{})
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to compile circuit: %v", err)
	}

	// Should perform MPC!
	pk, vk, err := groth16.Setup(ccs)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to setup circuit: %v", err)
	}

	return ccs, pk, vk, nil
}

// GenerateSemaphoreProof returns groth16 proof generated by the
// provided constaint system, proving key, private signals (secret, merkle proof, v.v)
func GenerateSemaphoreProof(
	ccs constraint.ConstraintSystem,
	pk groth16.ProvingKey,
	secret *big.Int,
	merkleProof leanIMT.MerkleProof,
	sProof SemaphoreProof,
) (*groth16_bn254.Proof, error) {
	// Calculate circuit inputs
	ml := len(merkleProof.Path)
	merkleLen := frontend.Variable(ml)
	merkleIndices := [MAX_DEPTH]frontend.Variable{}
	merkleSiblings := [MAX_DEPTH]frontend.Variable{}
	for i := 0; i < MAX_DEPTH; i++ {
		if i < ml {
			merkleIndices[i] = merkleProof.Path[i]
			merkleSiblings[i] = merkleProof.Siblings[i]
		} else {
			merkleIndices[i] = 0
			merkleSiblings[i] = "0"
		}
	}
	dummySquare := new(big.Int).Mul(sProof.Message, sProof.Message)

	// Init a circuit assignment to generate witness
	assignment := &circuits.Semaphore{
		Secret:              secret,
		MerkleProofLength:   merkleLen,
		MerkleProofIndices:  merkleIndices,
		MerkleProofSiblings: merkleSiblings,
		Message:             sProof.Message,
		Scope:               sProof.Scope,
		DummySquare:         dummySquare,
		MerkleRoot:          merkleProof.Root,
		Nullifier:           sProof.Nullifier,
	}
	witness, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField())
	if err != nil {
		return &groth16_bn254.Proof{}, fmt.Errorf("failed to calculate witness: %v", err)
	}

	// Generate groth16 proof
	proof, err := groth16.Prove(ccs, pk, witness)
	if err != nil {
		return &groth16_bn254.Proof{}, fmt.Errorf("failed to prove witness: %v", err)
	}

	return proof.(*groth16_bn254.Proof), nil
}

// VerifySemaphoreProof returns nil if the provided proof is correct
func VerifySemaphoreProof(
	vk groth16.VerifyingKey,
	proof *groth16_bn254.Proof,
	sProof SemaphoreProof, // semaphore proof
) error {
	dummySquare := new(big.Int).Mul(sProof.Message, sProof.Message)

	assignment := &circuits.Semaphore{
		MerkleRoot:  sProof.MerkleRoot,
		Message:     sProof.Message,
		DummySquare: dummySquare,
		Nullifier:   sProof.Nullifier,
		Scope:       sProof.Scope,
	}
	pubWit, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField(), frontend.PublicOnly())
	if err != nil {
		return fmt.Errorf("failed to create public witness: %v", err)
	}

	err = groth16.Verify(proof, vk, pubWit)
	if err != nil {
		return fmt.Errorf("failed to verify proof: %v", err)
	}
	return nil
}
